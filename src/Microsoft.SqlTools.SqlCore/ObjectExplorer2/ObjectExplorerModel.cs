//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

// This file was generated by a T4 Template. Do not modify directly, instead update the SmoQueryModelDefinition.xml file
// and re-run the T4 template. This can be done in Visual Studio by right-click in and choosing "Run Custom Tool",
// or from the command-line on any platform by running "build.cmd -Target=CodeGen" or "build.sh -Target=CodeGen".

using System.Collections.Generic;

namespace Microsoft.SqlTools.SqlCore.ObjectExplorer2
{
	/// <summary>
	/// Database Node
	/// </summary>
	public class DatabaseNode : TreeNode
	{
		public DatabaseNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Database";
			Type = "Database";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "Schema" && child.parentName == this.Name)
				{
					Children.Add(new SchemaNode(this, child));
				}
			}
		}
	}
	/// <summary>
	/// Schema Node
	/// </summary>
	public class SchemaNode : TreeNode
	{
		public SchemaNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Schema";
			Type = "Schema";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new TablesFolder(this));		
			Children.Add(new ViewsFolder(this));		
			Children.Add(new StoredProceduresFolder(this));		
			Children.Add(new FunctionsFolder(this));		
		}
	}
	/// <summary>
	/// Table Node
	/// </summary>
	public class TableNode : TreeNode
	{
		public TableNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Table";
			Type = "Table";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ColumnsFolder(this));		
			Children.Add(new IndexesFolder(this));		
		}
	}
	/// <summary>
	/// Column Node
	/// </summary>
	public class ColumnNode : TreeNode
	{
		public ColumnNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Column";
			Type = "Column";
			IsLeaf = true;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
		}
	}
	/// <summary>
	/// Index Node
	/// </summary>
	public class IndexNode : TreeNode
	{
		public IndexNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Index";
			Type = "Index";
			IsLeaf = true;
			AddParentInScriptingObject = true;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
		}
	}
	/// <summary>
	/// View Node
	/// </summary>
	public class ViewNode : TreeNode
	{
		public ViewNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "View";
			Type = "View";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ColumnsFolder(this));		
			Children.Add(new IndexesFolder(this));		
		}
	}
	/// <summary>
	/// StoredProcedure Node
	/// </summary>
	public class StoredProcedureNode : TreeNode
	{
		public StoredProcedureNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "StoredProcedure";
			Type = "StoredProcedure";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ParametersFolder(this));		
		}
	}
	/// <summary>
	/// Parameter Node
	/// </summary>
	public class ParameterNode : TreeNode
	{
		public ParameterNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "Parameter";
			Type = "Parameter";
			IsLeaf = true;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
		}
	}
	/// <summary>
	/// ScalarFunction Node
	/// </summary>
	public class ScalarFunctionNode : TreeNode
	{
		public ScalarFunctionNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "ScalarFunction";
			Type = "ScalarFunction";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ParametersFolder(this));		
		}
	}
	/// <summary>
	/// TableValuedFunction Node
	/// </summary>
	public class TableValuedFunctionNode : TreeNode
	{
		public TableValuedFunctionNode(TreeNode parent, ObjectMetadata metadata) : base(parent, metadata)
		{
			Icon = "TableValuedFunction";
			Type = "TableValuedFunction";
			IsLeaf = false;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ParametersFolder(this));		
		}
	}
	public class TablesFolder : FolderNode
	{
		public TablesFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Tables";
			Type = "Tables";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Tables;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "Table" && child.parentName == this.Parent.Name)
				{
					Children.Add(new TableNode(this, child));
				}
			}
		}
	}
	public class ColumnsFolder : FolderNode
	{
		public ColumnsFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Columns";
			Type = "Columns";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Columns;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "Column" && child.parentName == this.Parent.Name)
				{
					Children.Add(new ColumnNode(this, child));
				}
			}
		}
	}
	public class IndexesFolder : FolderNode
	{
		public IndexesFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Indexes";
			Type = "Indexes";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Indexes;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "Index" && child.parentName == this.Parent.Name)
				{
					Children.Add(new IndexNode(this, child));
				}
			}
		}
	}
	public class ViewsFolder : FolderNode
	{
		public ViewsFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Views";
			Type = "Views";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Views;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "View" && child.parentName == this.Parent.Name)
				{
					Children.Add(new ViewNode(this, child));
				}
			}
		}
	}
	public class StoredProceduresFolder : FolderNode
	{
		public StoredProceduresFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "StoredProcedures";
			Type = "StoredProcedures";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_StoredProcedures;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "StoredProcedure" && child.parentName == this.Parent.Name)
				{
					Children.Add(new StoredProcedureNode(this, child));
				}
			}
		}
	}
	public class ParametersFolder : FolderNode
	{
		public ParametersFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Parameters";
			Type = "Parameters";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Parameters;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "Parameter" && child.parentName == this.Parent.Name)
				{
					Children.Add(new ParameterNode(this, child));
				}
			}
		}
	}
	public class FunctionsFolder : FolderNode
	{
		public FunctionsFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "Functions";
			Type = "Functions";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_Functions;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			Children.Add(new ScalarFunctionsFolder(this));		
			Children.Add(new TableValuedFunctionsFolder(this));		
		}
	}
	public class ScalarFunctionsFolder : FolderNode
	{
		public ScalarFunctionsFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "ScalarFunctions";
			Type = "ScalarFunctions";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_ScalarValuedFunctions;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "ScalarFunction" && child.parentName == this.Parent.Parent.Name)
				{
					Children.Add(new ScalarFunctionNode(this, child));
				}
			}
		}
	}
	public class TableValuedFunctionsFolder : FolderNode
	{
		public TableValuedFunctionsFolder(TreeNode parent) : base(parent)
		{
			Icon = "Folder";
			Name = "TableValuedFunctions";
			Type = "TableValuedFunctions";
			IsLeaf = false;
			Label = SR.SchemaHierarchy_TableValuedFunctions;
		}
		public override void  LoadChildren(ObjectMetadata[] metadata)
		{
			this.Children = new List<TreeNode>();
			foreach(ObjectMetadata child in metadata)
			{
				if (child.Type == "TableValuedFunction" && child.parentName == this.Parent.Parent.Name)
				{
					Children.Add(new TableValuedFunctionNode(this, child));
				}
			}
		}
	}

	public static class ObjectExplorerModelQueries
	{
		public static Dictionary<string, string> Queries = new Dictionary<string, string>()
		{
			{ 
				"Schema", 
				@"
  SELECT
  SCHEMA_NAME AS schemaName,
  SCHEMA_NAME AS objectName,
  CATALOG_NAME AS parentName,
  SCHEMA_NAME AS displayName,
  'Schema' AS type,
  NULL AS subType
FROM
  INFORMATION_SCHEMA.SCHEMATA
WHERE
  SCHEMA_NAME NOT IN (
    'sys',
    'db_owner',
    'db_accessadmin',
    'db_securityadmin',
    'db_ddladmin',
    'db_backupoperator',
    'db_datareader',
    'db_datawriter',
    'db_denydatareader',
    'db_denydatawriter',
    'INFORMATION_SCHEMA',
    'guest'
  )
" 
			},
			{ 
				"Table", 
				@"
  SELECT
    TABLE_SCHEMA AS schemaName,
    TABLE_NAME AS objectName,
    TABLE_SCHEMA AS parentName,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME) AS displayName,
    'Table' AS ObjectType,
    NULL AS subType
  FROM
    INFORMATION_SCHEMA.TABLES
  WHERE
    TABLE_TYPE = 'BASE TABLE'
  " 
			},
			{ 
				"Column", 
				@"
    select 
    c.TABLE_SCHEMA as schemaName,
    c.COLUMN_NAME as objectName,    
    c.TABLE_NAME as parentName,
    c.COLUMN_NAME + 
    ' (' +
    CASE 
        when kcu.CONSTRAINT_NAME LIKE 'PK%' THEN 'PK, '
        ELSE ''
    END +
    CASE
        when kcu2.CONSTRAINT_NAME LIKE 'FK%' THEN 'FK, '
        ELSE ''
    END + 
    c.DATA_TYPE +
    CASE  
        when c.DATA_TYPE IN ('char', 'nchar', 'binary', 'varchar', 'nvarchar', 'varbinary') THEN
        CASE 
            when c.CHARACTER_MAXIMUM_LENGTH = -1 THEN '(max)'
            ELSE '(' +  CAST(c.CHARACTER_MAXIMUM_LENGTH AS NVARCHAR) + ')'
        END 
        when c.DATA_TYPE IN ('datetime2', 'time', 'datetimeoffset') THEN '(' +  CAST(c.NUMERIC_SCALE AS NVARCHAR) + ')'
        ELSE  ''
    END +
    -- logic for null/notnull
    CASE
        when c.is_nullable = 'NO' then ', null'
        ELSE ', not null'
    END +
     ')' 
     as displayName,
     'Column' as type,
     CASE
        when kcu.CONSTRAINT_NAME LIKE 'PK%' THEN 'PrimaryKey'
        when kcu2.CONSTRAINT_NAME LIKE 'FK%' THEN 'ForeignKey'  
        else NULL
    END
     as subType
from INFORMATION_SCHEMA.COLUMNS as c
LEFT JOIN
information_schema.KEY_COLUMN_USAGE as kcu ON c.TABLE_SCHEMA = kcu.TABLE_SCHEMA AND c.TABLE_NAME = kcu.TABLE_NAME AND c.COLUMN_NAME = kcu.COLUMN_NAME AND kcu.CONSTRAINT_NAME LIKE 'PK%'
LEFT JOIN
information_schema.KEY_COLUMN_USAGE as kcu2 ON c.TABLE_SCHEMA = kcu2.TABLE_SCHEMA AND c.TABLE_NAME = kcu2.TABLE_NAME AND c.COLUMN_NAME = kcu2.COLUMN_NAME AND kcu2.CONSTRAINT_NAME LIKE 'FK%'
    " 
			},
			{ 
				"Index", 
				@"
  SELECT
      S.name AS schemaName,
      I.name AS objectName,
      O.name AS parentName,
      I.name + ' (' +
      CASE when I.is_unique = 1 THEN 'Unique' ELSE 'Non-Unique' END + 
      ', ' +
      CASE when I.index_id = 1 THEN 'Clustered' ELSE 'Non-Clustered' END +
      ')'
      AS displayName,
      'Index' AS ObjectType,
      CASE when I.is_primary_key = 1 THEN 'PKINDEX' ELSE 'INDEX' END subType
  FROM
      sys.schemas AS S
      JOIN (select object_id, name, schema_id FROM sys.tables UNION ALL select object_id, name, schema_id from sys.views) AS O ON O.schema_id = S.schema_id
      JOIN sys.indexes AS I ON I.object_id = O.object_id
  Where I.name IS NOT NULL
  " 
			},
			{ 
				"View", 
				@"
  SELECT
    TABLE_SCHEMA AS schemaName,
    TABLE_NAME AS objectName,
    TABLE_SCHEMA AS parentName,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME) AS displayName,
    'View' AS ObjectType,
    NULL AS subType
  FROM
    INFORMATION_SCHEMA.TABLES
  WHERE
    TABLE_TYPE = 'VIEW'
  " 
			},
			{ 
				"StoredProcedure", 
				@"
  SELECT
    SPECIFIC_SCHEMA AS schemaName,
    SPECIFIC_NAME AS objectName,
    SPECIFIC_SCHEMA AS parentName,
    CONCAT(SPECIFIC_SCHEMA, '.', SPECIFIC_NAME) AS displayName,
    'StoredProcedure' AS ObjectType,
    NULL AS subType
  FROM
    INFORMATION_SCHEMA.ROUTINES
  WHERE
    ROUTINE_TYPE = 'PROCEDURE'
  " 
			},
			{ 
				"Parameter", 
				@"
    SELECT 
    S.name AS schemaName,
    p.name AS objectName,
    o.name AS parentName,
    p.name +  ' (' +  TP.name + ', ' +
    CASE WHEN P.is_output = 1 THEN 'Output' ELSE 'Input' END + ', ' +
    CASE WHEN P.has_default_value = 1 THEN 'Default' ELSE 'No default' END + ')'
    AS displayName, 
    'Parameter' AS type,
    CASE WHEN P.is_output = 1 THEN 'OutputParameter' ELSE 'InputParameter' END AS subtype
FROM 
sys.parameters AS p
JOIN sys.types AS TP ON P.user_type_id = TP.user_type_id
JOIN sys.objects AS o ON o.object_id = p.object_id
JOIN sys.schemas AS S ON O.schema_id = S.schema_id
WHERE p.name != NULL OR p.name != ''
" 
			},
			{ 
				"ScalarFunction", 
				@"
  SELECT
      S.name AS schemaName,
      P.name AS objectName,
      S.name AS parentName,
      CONCAT (S.name, '.', P.name) AS displayName,
      'ScalarFunction' AS ObjectType,
      NULL AS subType
  FROM
      sys.schemas AS S
      JOIN sys.objects AS P ON S.schema_id = P.schema_id
  WHERE
      P.type = 'FN'
  " 
			},
			{ 
				"TableValuedFunction", 
				@"
  SELECT
      S.name AS schemaName,
      P.name AS objectName,
      S.name AS parentName,
      CONCAT (S.name, '.', P.name) AS displayName,
      'TableValuedFunction' AS ObjectType,
      NULL AS subType
  FROM
      sys.schemas AS S
      JOIN sys.objects AS P ON S.schema_id = P.schema_id
  WHERE
      P.type = 'IF' OR P.type = 'TF'
  " 
			},
		};
	}
	
}

