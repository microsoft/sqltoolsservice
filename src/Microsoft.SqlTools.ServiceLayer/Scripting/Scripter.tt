<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//
// THIS FILE IS GENERATED BY A CODEGEN TOOL. DO NOT EDIT!!!!
// IF YOU NEED TO MAKE CHANGES, EDIT THE .TT FILE!!!

// To regenerate either (1) save the .TT file from Visual Studio or (2) run the build script codegen task.

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Specialized;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.SqlParser.Intellisense;
using Microsoft.SqlTools.Utility;
namespace Microsoft.SqlTools.ServiceLayer.Scripting
{
	internal partial class Scripter
    {

		<#
			///
			/// Generate Initialize method
			///
			var indent = "    ";
			var directory = Path.GetDirectoryName(Host.TemplateFile);
			string xmlFile = Path.Combine(directory, "ScripterSupportedTypes.xml");
			var supportedTypes = GetSupportedTypes(xmlFile);
			if (supportedTypes != null && supportedTypes.Count > 0)
			{
				WriteLine("private void Initialize()");
				PushIndent(indent);
				PushIndent(indent);
				WriteLine("{");
				PushIndent(indent);
				foreach(var typeProperty in supportedTypes)
				{
						string functionCall = string.Format("AddSupportedType(DeclarationType.{0}, Get{0}Scripts, \"{1}\", \"{2}\");", typeProperty["Name"], typeProperty["CreateSyntax"], typeProperty["QuickInfoType"]);
						WriteLine(functionCall);
				}
				PopIndent();
				WriteLine("}\n");

				///
				/// Generate scriptGetters for each type
				///

				foreach(var typeProperty in supportedTypes)
				{
					string statement;
					// Write comments
					WriteLine("/// <summary>");
					WriteLine(string.Format("/// Script a {0} using SMO", typeProperty["Name"]));
					WriteLine("/// </summary>");
					WriteLine(string.Format("/// <param name=\"objectName\">{0} name</param>", typeProperty["Name"]));
					WriteLine(string.Format("/// <param name=\"schemaName\">Schema name</param>"));
					WriteLine("/// <returns>String collection of scripts</returns>");

					WriteLine(string.Format("internal StringCollection Get{0}Scripts(string objectName, string schemaName, ScriptingOptions scriptingOptions = null)", typeProperty["Name"]));
					WriteLine("{");
					PushIndent(indent);

					// Write try block to retrieve object and return script
					WriteLine("try");
					WriteLine("{");
					if(typeProperty["SupportsSchemaQuery"].IndexOf("true", StringComparison.OrdinalIgnoreCase) >= 0)
					{
						statement = string.Format("{0} smoObject = string.IsNullOrEmpty(schemaName) ? new {0}(this.Database, objectName) : new {0}(this.Database, objectName, schemaName);", typeProperty["AccessClass"]);
					}
					else
					{
						// If it's a database
						if (typeProperty["AccessClass"] == "Database")
						{
							statement = string.Format("{0} smoObject = new {0}(new Server(this.serverConnection), objectName);", typeProperty["Name"]);
						}
						else 
						{
							statement = string.Format("{0} smoObject = new {0}(this.Database, objectName);", typeProperty["Name"]);
						}
					}
					PushIndent(indent);
					WriteLine(statement);
					WriteLine("smoObject.Refresh();");
					WriteLine("return smoObject.Script(scriptingOptions);");
					PopIndent();
					WriteLine("}");

					// Write catch block to catch and log exceptions
					WriteLine("catch (Exception ex)");
					WriteLine("{");
					PushIndent(indent);
					statement = string.Format("LogLevel.Error,\"Exception at PeekDefinition Get{0}Scripts : \" + ex.Message", typeProperty["Name"]);
					WriteLine("Logger.Write(" + statement + ");");
					WriteLine("return null;");
					PopIndent();
					WriteLine("}");
					PopIndent();
					WriteLine("}\n");
				}
			}
			PopIndent();
			PopIndent();
		#>
	}
}
	<#+
	///
	/// Get the supported types from the xml file
	///
	public static List<Dictionary<string, string>> GetSupportedTypes(string xmlFile)
	{
		List<Dictionary<string, string>> typeList = null;
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		XmlNodeList supportedTypes = doc.SelectNodes("/SupportedTypes/Type");
		if (supportedTypes != null)
		{
			typeList = new List<Dictionary<string, string>>();
			foreach (var type in supportedTypes)
			{
				XmlElement node = type as XmlElement;
				if (node != null)
				{
					string typeName = (node["Name"] != null) ? node["Name"].InnerText : null;
					string createSyntax = (node["CreateSyntax"] != null) ? node["CreateSyntax"].InnerText : null;
					string accessClass = (node["AccessClass"] != null) ? node["AccessClass"].InnerText : null;
					string supportsSchemaQuery = (node["SupportsSchemaQuery"] != null) ? node["SupportsSchemaQuery"].InnerText : null;
					string quickInfoType = (node["QuickInfoType"] != null) ? node["QuickInfoType"].InnerText : null;
					if (typeName != null && createSyntax != null && accessClass != null && supportsSchemaQuery!= null)
					{
						Dictionary<string, string> typeProperties = new Dictionary<string, string>();
						typeProperties.Add("Name", typeName);
						typeProperties.Add("CreateSyntax", createSyntax);
						typeProperties.Add("AccessClass", accessClass);
						typeProperties.Add("SupportsSchemaQuery", supportsSchemaQuery);
						typeProperties.Add("QuickInfoType", quickInfoType);
						typeList.Add(typeProperties);
					}

				}
			}
		}
		return typeList;
	}

	#>