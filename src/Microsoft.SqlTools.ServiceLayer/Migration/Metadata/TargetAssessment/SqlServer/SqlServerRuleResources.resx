<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UnqualifiedJoinTitle" xml:space="preserve">
    <value>Unqualified Join(s) detected</value>
  </data>
  <data name="UnqualifiedJoinIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="UnqualifiedJoinDescription" xml:space="preserve">
    <value>Starting with database compatibility level 90 and higher, in rare occasions, the 'unqualified join' syntax can cause 'missing join predicate' warnings, leading to long running queries.</value>
  </data>
  <data name="UnqualifiedJoinRecommendation" xml:space="preserve">
    <value>Use explicit JOIN syntax in all cases. SQL Server supports the below explicit joins: LEFT OUTER JOIN or LEFT JOIN, RIGHT OUTER JOIN or RIGHT JOIN, FULL OUTER JOIN or FULL JOIN, INNER JOIN.</value>
  </data>
  <data name="UnqualifiedJoinMoreInformation" xml:space="preserve">
    <value>Deprecation of "Old Style" JOIN Syntax</value>
  </data>
  <data name="UnqualifiedJoinMoreInformationlink" xml:space="preserve">
    <value>https://go.microsoft.com/fwlink/?LinkId=798568</value>
  </data>
  <data name="SyntaxErrorTitle" xml:space="preserve">
    <value>Syntax issue on the source server</value>
  </data>
  <data name="SyntaxErrorIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="SyntaxErrorDescription" xml:space="preserve">
    <value>While parsing the objects on the source database, one or more syntax issues were found. Syntax issues on the source database indicate that some objects contain unsupported syntax in the server version and database compatibility level.</value>
  </data>
  <data name="SyntaxErrorRecommendation" xml:space="preserve">
    <value>Review the list of objects and issues reported, fix the syntax errors, and re-run assessment before migrating this database.</value>
  </data>
  <data name="SyntaxErrorMoreInformation" xml:space="preserve">
    <value />
  </data>
  <data name="SyntaxErrorMoreInformationlink" xml:space="preserve">
    <value />
  </data>
  <data name="OrderByIntegerLiteralTitle" xml:space="preserve">
    <value>ORDER BY specifies integer ordinal</value>
  </data>
  <data name="OrderByIntegerLiteralIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="OrderByIntegerLiteralDescription" xml:space="preserve">
    <value>Order the result set of a query by the specified column list and, optionally, limit the rows returned to a specified range. The order in which rows are returned in a result set are not guaranteed unless an ORDER BY clause is specified.,"Specify the sort column as a name or column alias rather than hard coding the ordinal.</value>
  </data>
  <data name="OrderByIntegerLiteralRecommendation" xml:space="preserve">
    <value>This rule checks stored procedures, functions, views and triggers for use of ORDER BY clause specifying ordinal column numbers as sort columns. A sort column can be specified as a nonnegative integer representing the position of the name or alias in the select list, but this is not recommended. An integer cannot be specified when the order_by_expression appears in a ranking function. A sort column can include an expression</value>
  </data>
  <data name="OrderByIntegerLiteralMoreInformation" xml:space="preserve">
    <value>But when the database is in SQL 90 compatibility mode or higher, the expression cannot resolve to a constant.</value>
  </data>
  <data name="OrderByIntegerLiteralMoreInformationlink" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql?view=sql-server-ver15</value>
  </data>
  <data name="BackupLogTitle" xml:space="preserve">
    <value>BACKUP LOG WITH NO_LOG|TRUNCATE_ONLY statements are not supported</value>
  </data>
  <data name="BackupLogIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="BackupLogDescription" xml:space="preserve">
    <value>Backing Up the Transaction Log (full and bulk-logged recovery models)</value>
  </data>
  <data name="BackupLogRecommendation" xml:space="preserve">
    <value>Remove BACKUP LOG WITH NO_LOG|TRUNCATE_ONLY statements from scripts. Microsoft highly recommends to set your database recovery to FULL recovery mode and perform regular transactional log backups to prevent the log from growing too big. If you do not need point-in-time recovery, switch to SIMPLE recovery mode.</value>
  </data>
  <data name="BackupLogMoreInformation" xml:space="preserve">
    <value>Assessment detected BACKUP LOG WITH NO_LOG|TRUNCATE_ONLY statements. These backup/restore options are not supported anymore.</value>
  </data>
  <data name="BackupLogMoreInformationlink" xml:space="preserve">
    <value>BACKUP (Transact-SQL) https://go.microsoft.com/fwlink/?LinkID=698472</value>
  </data>
  <data name="BackupPasswordTitle" xml:space="preserve">
    <value>Remove the use of PASSWORD in BACKUP command</value>
  </data>
  <data name="BackupPasswordIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="BackupPasswordDescription" xml:space="preserve">
    <value>Some of the detected BACKUP command options have been deprecated or discontinued such as, BACKUP { DATABASE | LOG } WITH PASSWORD and BACKUP { DATABASE | LOG } WITH MEDIAPASSWORD.</value>
  </data>
  <data name="BackupPasswordRecommendation" xml:space="preserve">
    <value>Remove the use of BACKUP { DATABASE | LOG } WITH PASSWORD and BACKUP { DATABASE | LOG } WITH MEDIAPASSWORD commands. Replace them with the currently supported BACKUP command syntax. This syntax should not be used for creating future restore scripts.</value>
  </data>
  <data name="BackupPasswordMoreInformation" xml:space="preserve">
    <value>See BACKUP (Transact-SQL)</value>
  </data>
  <data name="BackupPasswordMoreInformationlink" xml:space="preserve">
    <value>https://go.microsoft.com/fwlink/?LinkId=798527</value>
  </data>
  <data name="LOBDataTypesTitle" xml:space="preserve">
    <value>Deprecated data types TEXT, IMAGE or NTEXT</value>
  </data>
  <data name="LOBDataTypesIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="LOBDataTypesDescription" xml:space="preserve">
    <value>These data types are checked as deprecated. In some cases, using TEXT, IMAGE or NTEXT might harm performance.</value>
  </data>
  <data name="LOBDataTypesRecommendation" xml:space="preserve">
    <value>Deprecated data types are marked to be discontinued on next versions of SQL Server, should use new data types such as: (varchar(max), nvarchar(max), varbinary(max) and etc.)</value>
  </data>
  <data name="LOBDataTypesMoreInformation" xml:space="preserve">
    <value>ntext, text, and image (Transact-SQL)</value>
  </data>
  <data name="LOBDataTypesMoreInformationlink" xml:space="preserve">
    <value>https://go.microsoft.com/fwlink/?LinkId=798558</value>
  </data>
  <data name="OrderByNonIntegerConstantTitle" xml:space="preserve">
    <value>Constant expressions are not allowed in the ORDER BY clause in 90 or later compatibility modes</value>
  </data>
  <data name="OrderByNonIntegerConstantIssueCategory" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="OrderByNonIntegerConstantDescription" xml:space="preserve">
    <value>Constant expressions are allowed (and ignored) in the ORDER BY clause when the database compatibility mode is set to 80 or earlier. However, these expressions in the ORDER BY clause will cause the statement to fail when the database compatibility mode is set to 90 or later.Here is an example of such problematic statements:SELECT * FROM Production.ProductORDER BY CASE WHEN  1=2 THEN 3 ELSE 2 END</value>
  </data>
  <data name="OrderByNonIntegerConstantRecommendation" xml:space="preserve">
    <value>Before you change the database compatibility mode to 90 or later, modify statements that use constant expressions in the ORDER BY clause to use a column name or column alias, or a nonnegative integer representing the position of the name or alias in the select list.</value>
  </data>
  <data name="OrderByNonIntegerConstantMoreInformation" xml:space="preserve">
    <value />
  </data>
  <data name="OrderByNonIntegerConstantMoreInformationlink" xml:space="preserve">
    <value />
  </data>
  <data name="GeoDataTypeTitle" xml:space="preserve">
    <value>Remove user-defined type (UDT)s named after the reserved GEOMETRY and GEOGRAPHY data types.</value>
  </data>
  <data name="GeoDataTypeIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="GeoDataTypeDescription" xml:space="preserve">
    <value>Microsoft SQL Server introduced new data types GEOMETRY and GEOGRAPHY for storing &amp;quot;Spatial Data&amp;quot;. The terms used for spatial data types should not be used as names for either common language runtime (CLR) or alias UDTs.</value>
  </data>
  <data name="GeoDataTypeRecommendation" xml:space="preserve">
    <value>Remove UDTs named after the reserved GEOMETRY and GEOGRAPHY data types.</value>
  </data>
  <data name="GeoDataTypeMoreInformation" xml:space="preserve">
    <value>Remove UDTs named after the reserved GEOMETRY and GEOGRAPHY data types</value>
  </data>
  <data name="GeoDataTypeMoreInformationlink" xml:space="preserve">
    <value>https://go.microsoft.com/fwlink/?LinkID=724415</value>
  </data>
  <data name="ForBrowseViewTitle" xml:space="preserve">
    <value>FOR BROWSE is not allowed in views in 90 or later compatibility modes</value>
  </data>
  <data name="ForBrowseViewIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="ForBrowseViewDescription" xml:space="preserve">
    <value>The FOR BROWSE clause is allowed (and ignored) in views when the database compatibility mode is set to 80. The FOR BROWSE clause is not allowed in views when the database compatibility mode is set to 90 or later.</value>
  </data>
  <data name="ForBrowseViewRecommendation" xml:space="preserve">
    <value>Before you change the database compatibility mode to 90 or later, remove the FOR BROWSE clause from view definitions.</value>
  </data>
  <data name="ForBrowseViewMoreInformation" xml:space="preserve">
    <value>See FOR BROWSE</value>
  </data>
  <data name="ForBrowseViewMoreInformationlink" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/sql/t-sql/queries/select-for-clause-transact-sql?view=sql-server-ver15#for-browse</value>
  </data>
  <data name="CheckOptionTopViewTitle" xml:space="preserve">
    <value>WITH CHECK OPTION is not supported in views that contain TOP in compatibility mode 90 and above</value>
  </data>
  <data name="CheckOptionTopViewIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="CheckOptionTopViewDescription" xml:space="preserve">
    <value>Assessment detected a view that uses the WITH CHECK OPTION and a TOP clause in the SELECT statement of the view or in a referenced view. Views defined this way incorrectly allow data to be modified through the view and may produce inaccurate results when the database compatibility mode is set to 80 and earlier. Data cannot be inserted or updated through a view that uses WITH CHECK OPTION when the view or a referenced view uses the TOP clause and the database compatibility mode is set to 90 or later.</value>
  </data>
  <data name="CheckOptionTopViewRecommendation" xml:space="preserve">
    <value>Modify views that use both WITH CHECK OPTION and TOP if data modification through the view is required.</value>
  </data>
  <data name="CheckOptionTopViewMoreInformation" xml:space="preserve">
    <value />
  </data>
  <data name="CheckOptionTopViewMoreInformationlink" xml:space="preserve">
    <value />
  </data>
  <data name="ForXmlAutoDerivedTableTitle" xml:space="preserve">
    <value>FOR XML AUTO queries return derived table references in 90 or later compatibility modes</value>
  </data>
  <data name="ForXmlAutoDerivedTableIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="ForXmlAutoDerivedTableDescription" xml:space="preserve">
    <value>When the database compatibility level is set to 90 or later, FOR XML queries that execute in AUTO mode return references to derived table aliases. When the compatibility level is set to 80, FOR XML AUTO queries return references to the base tables that define a derived table. For example, the following query, which includes a derived table, produces different results under compatibility levels 80, 90, or later:SELECT * FROM(SELECT a.id AS a, b.id AS bFROM Test a JOIN Test b ON a.id=b.id) AS DerivedTest FOR XML AUTO;Under compatibility level 80, the query returns the following results. The results reference the base table aliases a and b of the derived table instead of the derived table alias.&amp;lt;a a=&amp;quot;1&amp;quot;&amp;gt;&amp;lt;b b=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a a=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;b b=&amp;quot;2&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;Under compatibility level 90 or later, the query returns references to the derived table alias DerivedTest instead of to the derived table's base tables.&amp;lt;DerivedTest a=&amp;quot;1&amp;quot; b=&amp;quot;1&amp;quot;/&amp;gt;&amp;lt;DerivedTest a=&amp;quot;2&amp;quot; b=&amp;quot;2&amp;quot;/&amp;gt;</value>
  </data>
  <data name="ForXmlAutoDerivedTableRecommendation" xml:space="preserve">
    <value>Modify your application as required to account for the changes in results of FOR XML AUTO queries that include derived tables and that run under compatibility level 90 or later.</value>
  </data>
  <data name="ForXmlAutoDerivedTableMoreInformation" xml:space="preserve">
    <value />
  </data>
  <data name="ForXmlAutoDerivedTableMoreInformationlink" xml:space="preserve">
    <value />
  </data>
  <data name="DBCCTitle" xml:space="preserve">
    <value>Discontinued DBCC commands referenced in your T-SQL objects</value>
  </data>
  <data name="DBCCIssueCategory" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="DBCCDescription" xml:space="preserve">
    <value>Many DBCC commands that were available in prior releases have been replaced with DMVs and DMFs, or no longer exist; therefore, using these commands may cause errors and unforeseen effects after upgrading your SQL Server.</value>
  </data>
  <data name="DBCCRecommendation" xml:space="preserve">
    <value>Re-write the code, replace \DBCC DBREINDEX\" with \"ALTER INDEX\" with \"REBUILD\" option. Re-write the code  replace \"DBCC INDEXDEFRAG\" with \"ALTER INDEX\" with \"REORGANIZE\" option.Re-write the code  replace \"DBCC SHOWCONTIG\" with \"sys.dm_db_index_physical_stats\". Use of DBCC PINTABLE/DBCC UNPINTABLE is not required and has been removed to prevent additional problems. The syntax for this command still works but does not affect the server. Refer to SQL Server books online for equivalent DMVs and DMFs that you may want to use instead of deprecated and discontinued DBCC commands."</value>
  </data>
  <data name="DBCCMoreInformation" xml:space="preserve">
    <value>Deprecated Database Engine Features in SQL Server</value>
  </data>
  <data name="DBCCMoreInformationlink" xml:space="preserve">
    <value>https://go.microsoft.com/fwlink/?LinkID=698477</value>
  </data>
</root>