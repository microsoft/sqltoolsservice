<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//
using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Specialized;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.SqlParser.Intellisense;
using Microsoft.SqlTools.ServiceLayer.Utility;
namespace Microsoft.SqlTools.ServiceLayer.LanguageServices
{
	internal partial class PeekDefinition
    {

		<#
			///
			/// Generate Initialize method
			///
			var directory = Path.GetDirectoryName("src\\Microsoft.SqlTools.ServiceLayer\\LanguageServices\\");
			string xmlFile = Path.Combine(directory, "PeekDefinitionSupportedTypes.xml");
			var supportedTypes = GetSupportedTypes(xmlFile);
			if (supportedTypes != null && supportedTypes.Count > 0)
			{
				WriteLine("private void Initialize()");
				WriteLine("\t\t{");
				foreach(var typeProperty in supportedTypes)
				{
						string functionCall = string.Format("\t\t\tAddSupportedType(DeclarationType.{0}, Get{0}Scripts, \"{1}\");", typeProperty["Name"], typeProperty["CreateSyntax"]);
						WriteLine(functionCall);
				}
				WriteLine("\t\t}\n");

				///
				/// Generate scriptGetters
				///

				foreach(var typeProperty in supportedTypes)
				{
					string statement;
					// Write comments
					WriteLine("\t\t/// <summary>");
					WriteLine(string.Format("\t\t/// Script a {0} using SMO", typeProperty["Name"]));
					WriteLine("\t\t/// </summary>");
					WriteLine(string.Format("\t\t/// <param name=\"objectName\">{0} name</param>", typeProperty["Name"]));
					WriteLine(string.Format("\t\t/// <param name=\"schemaName\">Schema name</param>"));
					WriteLine("\t\t/// <returns>String collection of scripts</returns>");

					WriteLine(string.Format("\t\tinternal StringCollection Get{0}Scripts(string objectName, string schemaName)", typeProperty["Name"]));
					WriteLine("\t\t{");

					// Write try block to retrieve object and return script
					WriteLine("\t\t\t" + "try");
					WriteLine("\t\t\t{");
					if(typeProperty["SupportsSchemaQuery"].IndexOf("true", StringComparison.OrdinalIgnoreCase) >= 0)
					{
					statement = string.Format("{0} smoObject = string.IsNullOrEmpty(schemaName) ? new {0}(this.Database, objectName) : new {0}(this.Database, objectName, schemaName);", typeProperty["AccessClass"]);
					}
					else
					{
					statement = string.Format("{0} smoObject = new {0}(this.Database, objectName);", typeProperty["Name"]);
					}
					WriteLine("\t\t\t\t" + statement);
					WriteLine("\t\t\t\t" + "smoObject.Refresh();");
					WriteLine("\t\t\t\t" + "return smoObject.Script();");
					WriteLine("\t\t\t}");

					// Write catch block to catch and log exceptions
					WriteLine("\t\t\tcatch (Exception ex)");
					WriteLine("\t\t\t{");
					statement = string.Format("LogLevel.Error,\"Exception at PeekDefinition Get{0}Scripts : \" + ex.Message", typeProperty["Name"]);
					WriteLine("\t\t\t\tLogger.Write(" + statement + ");");
					WriteLine("\t\t\t\treturn null;");
					WriteLine("\t\t\t}");
					WriteLine("\t\t}\n");
				}
			}
		#>
	}
}
	<#+
	public static List<Dictionary<string, string>> GetSupportedTypes(string xmlFile)
	{
		List<Dictionary<string, string>> typeList = null;
		XmlDocument doc = new XmlDocument();
		doc.Load(xmlFile);
		XmlNodeList supportedTypes = doc.SelectNodes("/SupportedTypes/Type");
		if (supportedTypes != null)
		{
			typeList = new List<Dictionary<string, string>>();
			foreach (var type in supportedTypes)
			{
				XmlElement node = type as XmlElement;
				if (node != null)
				{
					string typeName = node["Name"]?.InnerText;
					string createSyntax = node["CreateSyntax"]?.InnerText;
					string accessClass = node["AccessClass"]?.InnerText;
					string supportsSchemaQuery = node["SupportsSchemaQuery"]?.InnerText;
					if (typeName != null && createSyntax != null && accessClass != null && supportsSchemaQuery!= null)
					{
						Dictionary<string, string> typeProperties = new Dictionary<string, string>();
						typeProperties.Add("Name", typeName);
						typeProperties.Add("CreateSyntax", createSyntax);
						typeProperties.Add("AccessClass", accessClass);
						typeProperties.Add("SupportsSchemaQuery", supportsSchemaQuery);
						typeList.Add(typeProperties);
					}

				}
			}
		}
		return typeList;
	}

	#>